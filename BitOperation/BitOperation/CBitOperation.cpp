#include "CBitOperation.h"

/************************************************************************/
/* 
题目：判断一个正整数num是否为2的N次方
基本思想：
   十进制		二进制		N-1			N&N-1		是否为2的乘方
     8			 1000		111			  0				是
	16			10000	   1111			  0				是
	32		   100000	  11111			  0				是
   100		  1100100	1100011		  1100000			否

算法时间复杂度为O(1)，空间复杂度为O(1)
*/
/************************************************************************/
bool CBitOperation::Is2pow(int num) {	
	if (num <= 0){
		return false;
	}
	return (num & (num-1)) == 0;
}

/************************************************************************/
/* 
题目：判断一个正整数num是否为2的N次方(常规解法1)

算法时间复杂度为O(logN)，空间复杂度为O(1)											
*/
/************************************************************************/
bool CBitOperation::Is2pow_1(int num) {	
	if (num <= 0){
		return false;
	}
	int temp = 1;
	while(temp <= num) {
		if (temp == num) {
			return true;
		}
		temp = temp * 2;
	}
	return false;
}

/************************************************************************/
/* 
题目：判断一个正整数num是否为2的N次方(常规解法2)
   
算法时间复杂度为O(logN)，空间复杂度为O(1)										
*/
/************************************************************************/
bool CBitOperation::Is2pow_2(int num) {	
	if (num <= 0){
		return false;
	}
	int temp = 1;
	while(temp <= num) {
		if (temp == num) {
			return true;
		}
		temp = temp << 1; // 位运算比乘法运算性能高，在一定程度提高性能	
	}
	return false;
}

/************************************************************************/
/* 
题目：计算一个正整数num转化为二进制后，"1"的个数。
基本思想：从右到左依次去除"1"，并统计其个数。

算法的计算次数只与num的位数有关，与其大小无关。
算法时间复杂度为O(logN)，空间复杂度为O(1)												
*/
/************************************************************************/
int CBitOperation::NumberofOne(int num) {
	if (num <= 0){
		return 0;
	}
	int count = 0;
	while (num) {
		num = num & (num-1);
		count++;
	}
	return count;
}

/************************************************************************/
/* 
题目：计算一个正整数num转化为二进制后，"0"的个数。
基本思想：从右到左依次与1进行与操作，并统计其个数。

算法的计算次数只与num的位数有关，与其大小无关。
算法时间复杂度为O(logN)，空间复杂度为O(1)												
*/
/************************************************************************/
int CBitOperation::NumberofZero(int num) {
	if (num <= 0){
		return 0;
	}
	int count = 0;
	while (num) {
		if ((num & 0x01) != 1){
			count++;
		}
		num = num >> 1;
	}
	return count;
}

/************************************************************************/
/* 
题目：一个无序数组里有若干个正整数，范围从1到100，其中99个整数都出现了
偶数次，只有一个整数出现了奇数次（比如1,1,2,2,3,3,4,5,5），如何找到这个
出现奇数次的整数。
基本思想：如果两个数相等，那么其异或运算为0。因此依次对数组中每个数进行
异或运算，那么最后的结果即为所求。
*/
/************************************************************************/
int CBitOperation::LostNumber1(int num[], int len) {
	int temp = 0;
	for (int i=0; i<len; i++) {
		temp ^= num[i];
	}
	return temp;
}

/************************************************************************/
/* 
题目：一个无序数组里有若干个正整数，范围从1到100，其中98个整数都出现了
偶数次，只有两个整数出现了奇数次（比如1,1,2,2,3,4,5,5），如何找到这个
出现奇数次的整数。
基本思想：如果两个数相等，那么其异或运算为0。因此依次对数组中每个数进行
异或运算，那么最后的结果即为所求。
*/
/************************************************************************/
int CBitOperation::LostNumber2(int num[], int len) {
	int temp = 0;
	for (int i=0; i<len; i++) {
		temp ^= num[i];
	}
	return temp;
}