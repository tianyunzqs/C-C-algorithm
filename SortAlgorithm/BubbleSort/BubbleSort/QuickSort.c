/********************** 快速排序 ****************************
基本思想：在待排序的n个记录中任取一个记录（通常取第一个记录），
		  以该记录为基准，将当前的无序区划分为左右两个较小的无
		  序子区，使左边的记录均小于基准值，右边的记录均大于或
		  等于基准值，基准值位于两个无序区的中间位置（即该记录
		  最终的排序位置）。之后，分别对两个无序区进行上述的划
		  分过程，直到无序区所有记录都排序完毕。
*************************************************************/

/*************************************************************
函数名称：static void swap(int *a, int *b)
参    数：int *a---整型指针
		  int *b---整型指针
功    能：交换两个整数的位置
返 回 值：无
说    明：static关键字指明了该函数只能在本文件中使用
**************************************************************/
static void swap(int *a, int *b)
{  
    int temp = *a;
    *a = *b;
    *b = temp;
}

int quickSortNum = 0; // 快速排序算法所需的趟数
/*************************************************************
函数名称：static int partition(int a[], int low, int high)
参    数：int a[]---待排序的数据
		  int low---无序区的下限值
		  int high---无序区的上限值
功    能：完成一趟快速排序
返 回 值：基准值的最终排序位置
说    明：static关键字指明了该函数只能在本文件中使用
**************************************************************/
static int partition(int a[], int low, int high)
{
    int privotKey = a[low];  //基准元素
    while(low < high)
	{   //从表的两端交替地向中间扫描  
        while(low < high  && a[high] >= privotKey)   // 找到第一个小于privotKey的值
			high--;  //从high所指位置向前搜索，至多到low+1位置  
        swap(&a[low], &a[high]);  // 将比基准元素小的交换到低端

        while(low < high  && a[low] <= privotKey)   // 找到第一个大于privotKey的值
			low++;  //从low所指位置向后搜索，至多到high-1位置
        swap(&a[low], &a[high]);  // 将比基准元素大的交换到高端
    }
	quickSortNum++;  // 快速排序趟数加1
	return low;  // 返回基准值所在的位置
}  

/*************************************************************
函数名称：void QuickSort(int a[], int low, int high)
参    数：int a[]---待排序的数据
		  int low---无序区的下限值
		  int high---无序区的上限值
功    能：完成快速排序算法，并将排序完成的数据存放在数组a中
返 回 值：无
说    明：使用递归方式完成
**************************************************************/
void QuickSort(int a[], int low, int high)
{  
    if(low < high)
	{
        int privotLoc = partition(a, low, high); // 将表一分为二  
        QuickSort(a, low, privotLoc-1);          // 递归对低子表递归排序  
        QuickSort(a, privotLoc+1, high);         // 递归对高子表递归排序  
    }	
}