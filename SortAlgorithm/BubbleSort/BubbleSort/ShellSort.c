/************************ 希尔排序(缩小增量排序) ************************
函数名称：void ShellSort(int a[], int len)
参    数：int a[]---待排序的数据
		  int len---待排序数据的个数，也即数组a的长度
功    能：完成希尔排序(缩小增量排序)
返 回 值：无
基本思想：首先取一个小于n的整数d1作为第一个增量，把全部记录分为d1个组，所有
		  间隔为d1的记录放在同一个组中，在各组内进行直接插入排序（也可采用
		  冒泡排序等其他排序方法），这样一次分钟排序的过程称为一趟排序；然后
		  取第二个增量d2<d1重复上述的分组和排序，直到所取的增量dm=1，即所有
		  记录放在同一组中进行直接插入排序为止。
		  希尔排序可以通过三重循环来实现。外循环是以各种不同增量值对序列进行
		  分组，直到d=1；第二层循环是在某一个增量值di下对各个子序列进行插入
		  排序。
说    明：排序好的数据依然存放在数组a中
*************************************************************************/
void ShellSort(int a[], int len)
{
	int i, j, d, temp; // temp为哨兵  d为增量
	for(d=len/2; d>=1; d/=2)  // 增量值有多少个，就进行多少趟排序
	{
		// 当d=1时，下面的二重for循环就是直接插入排序（简单插入排序）
		for(i=d; i<len; i++) // 每趟最多进行len-d次排序
		{
			temp = a[i];  // 将每次待排序的元素复制为哨兵
			for(j=i-d; j>=0&&a[j]>temp; j-=d)  // 从a[i-d]到a[0]逐个与哨兵(a[i])比较，大于哨兵的就后移
				a[j+d] = a[j];				  // 直到遇到小于或等于哨兵的元素或是遇到a[0]
			a[j+d] = temp;  // 将哨兵(也即待排序的元素)插入到第一个小于或等于哨兵元素之后			
		}
	}



	//int i, j, d, temp; // temp为哨兵  d为增量
	//int exchange, c=0;
	//for(d=len/2; d>=1; d/=2)  // 增量值有多少个，就进行多少趟排序
	//{	
	//	// 分组后进行冒泡排序
	//	for(i=0; i<len-d; i++) // 每趟最多进行len-d次排序
	//	{			
	//		for(j=0; j<len-d-i; j++)  // 每次排序最多进行len-d-i次比较
	//		{
	//			exchange = 0;
	//			if(a[j] > a[j+d])
	//			{
	//				temp = a[j];
	//				a[j] = a[j+d];
	//				a[j+d] = temp;
	//				exchange = 1;
	//			}
	//			c++;  // 第di个分组内比较的次数
	//		}
	//		if(exchange==0)
	//			break;
	//	}
	//	printf("%d\n",c);
	//}
}